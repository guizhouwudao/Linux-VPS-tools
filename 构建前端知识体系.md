<!-- @format -->

#### 构建前端知识体系

知识是无穷无尽的,问题也是无穷无尽的,需要我们静下心来想问题,解决问题,学会基本操作然后再深入学习

1. 如何构建前端知识体系

2. 找准知识体系,刻意练习,及时反馈

3. 结构化的知识体系

4. 有组织,结构化,易拓展

##### HTML CSS 面试

1. html面试题
   1. html:5 或!：用于HTML5文档类型
   2. html:xt：用于XHTML过渡文档类型
   3. html:4s：用于HTML4严格文档类型
常用过渡文档类型  html:xt  直接ctrl+e  或者tab
    1. html 标签语义化: 
         1: 根据展示的内容定义不同的标签,而不是全部都使用div布局,方便SEO蚂蚁抓取,提高网站权重 让人更容易读懂代码(增加代码可读性
    2. 行内元素与块级元素的区别,有哪些块级元素和行内元素?
         2: (display: block) 块级元素独占一行,
         (display: inline)|行内元素排列在一行上,块级元素可以定义宽高、上下内/外边距,行内元素无法定义宽高,宽高是默认为元素内容,无法定义元素上/下外边距(可以定义元素内边距)
         (display: inline-block): 行内块元素: 既有行内元素排列成一行的特性也有可以定义宽高,垂直方向内/外边距的特性
         3: 块级标签有: div p h1~h6 table tr ul li td ol dt dl dd  form lenged header main footer article section nav
         4: 行内标签有：span i u  s b strong font 
         5: 行内块标签有: 表单标签(input checkbox radio )  img     

2. css面试题
    1. css面试题:
        1: 盒子模型(怪异模型 chrome,firefox): content-box  width = width + padding + border  示例答案: 122px
        2: 盒子模型(标准模型 IE): siziing-box width = width - padding - border 
    2. 外边距合并问题: 
        1: 多个块级元素垂直外边距合并 (塌陷)
         相邻元素的margin-top和margin-bottom会重叠 (空白元素会一层层重叠,忽略不计) 以较大值作为外边距

        ```
       1. 通过添加透明(与背景颜色相同的边框)border padding(内边距)  
       ```
        2: 外边距为负值问题
      ```
        2.1 理解误区
        1: top: 向上移动 left: 向右移动 right: 向左移动 bottom: 向上移动 
        总结: 向反方向移动
        正解
        margin-top margin-left 为负值,向反方向移动 margin-top(向上移动) margin-left(向左移动)
        margin-bottom: 自身元素不动,其他元素向上移动 margin-right: 自身元素不动,其他元素向左移动
      ```
    3. 什么是BFC,如何应用?
         BFC: 一块独立渲染的区域,内部元素的渲染不会影响到边界以外的元素
         BFC: 块级格式上下文 触发BFC: 父元素设置 overflow: hidden 设置为块级元素 display: block tab tab-cell
          补充: overflow: hidden(overflow属性不为visible时候) display: block(display属性不为inline的时候)
                position: fixed(固定定位)|absolute(绝对定位)  
    4. PC端常用布局 float(浮动) (圣杯布局+双飞翼布局)
    1. float(布局)
    2. 中间内容先渲染,两边使用固定宽度,两边使用margin负值以便和中间内容横向重叠
    3. 一个使用padding留白,一个使用margin留白防止中间内容被覆盖s
    圣杯布局:
    1. float布局
    三栏布局,中间一栏最先加载和渲染 (内容最重要)
    两侧内容宽度固定,中间宽度自适应 (通过padding给两侧预留间隙)
    一般用于PC端网页
    5. flex 布局
       1. display flex 设置父元素为弹性盒子
       2. display-direction 设置元素主轴方向
       3. justify-content 主轴方向元素的排列方式
       4. align-items 侧轴方向元素的排列方式
       5. align-self 单个元素的排列方式(在元素上设置)
    居中对齐方式:
     1. 行内元素水平居中 inline: text-center  块级元素水平水平居中 margin: auto 
     2. 定位元素(absolute)水平居中 left: 50% +  margin-left: 自身宽度的一半(负值) 需要了解元素的width
     3.  left: 50% + transform: translate(-50%,0) css3新增元素 有兼容性问题 不需要知道元素的宽    
     4. 垂直居中 line-height = height
     5. 定位元素 top: 50% + margin-top 自身高度的一半(负值) 注: 需要知道元素的height
     6. top: 50% + transform: translate(0,-50%) css3新增元素 有兼容性问题 不需要知道元素的高
       >无兼容性问题的垂直居中对齐 top: 0 right: 0 bottom: 0 left: 0  + margin: auto
        >>position: relative; 根据元素自身(左上角)定位,不会影响别的元素位置
        >>position: absolute: 根据最近有定位的父元素的位置进行定位,如果父元素没有则根据body进行定位
   
     #### @media媒体查询实现响应式页面 
        1. px: 绝对长度单位
        2. em: 相对长度单位 (相对于父元素)
        3. rem: 相对长度单位 (相对于根元素 html的font-size)
         > 根元素html设置font-size: 100px  1rem = 100px 
         >html {
            font-size: 100px;
    // 1vh: 网页视口的1/100 1vw: 网页视口的1/100
    // vmax: vh与vw相比较,选择其中较大的一个 (一般情况下vh>vw 手机端,具体分析)
    // vmin: vh与vw相比较,选中其中较小的一个(一般情况下vw<vh)
    ```
    获取设备屏幕的高度和宽度 (window.screen.height/width)
    获取视口(除开遮挡的顶部和底部)的高度和宽度 (window.innerHeight/innerWidth)
    获取网页内容(body)的宽度和高度 (document.body.clientHeight/clientWidth)
    ```
    #### 2.js
        函数一般不用来存储值所以不存在复制或者拷贝的情况
        浅拷贝: 仅拷贝地址,拷贝后对象对象发生变化被拷贝的对象也会发生变化
        深拷贝: 拷贝后对象的值储存到一个新的空间,返回的新对象的属性或属性值发生变化不会影响到原来的对象
        变量直接赋值 obj2 = obj1
        深拷贝实现方式 JSON.stringify() 与 JSON.parse() 不能拷贝function,regexp,undefined
        深拷贝(递归实现) 可以拷贝function,但是不能拷贝regexp和undefined
        浅拷贝 不能拷贝function,regexp,undefined
        typeof 判断值类型
        typeof 判断函数(function)
        typeof 判断引用类型(object)不可再分-意为所有的引用类型都判断为object
        Object.assign(目标对象(拷贝到当前),拷贝对象) 如果只有一层的时候就是深拷贝,键值对,如果值是一个引用类型就是浅拷贝
    
       1. 除非用于判断 是否==null,其他时候一律用 ===
       2. 例如 if(age.key == null) 实质是 判断null和undefined的 === 的并集 if(age.key === null || age.key === undefined)
      #### truly: !!取非运算 以后为true的值(为原来的值) !!a === true
      #### falsly: !!取非运算以后为false的值(原来的值) !!a === false
      ```
      const a = '' if(a) {console.log('判断一个条件是否成立,实质是判断falsly还是truly')}

       字符串拼接 数字与别的类型相加只要加的不是Number类型都是字符串拼接,null会转换成0,undefied转换失败变成NaN,Symbol转换失败变成NaN
       特殊情况 console.log(null == undefined) 结果为 true console.log([] == {}) 结果为false console.log([] == []) 结果为false > 引用类型地址存储在栈上,值存储在堆上, [] 与 [] 地址指向不同 
      ```
        js中的逻辑运算符
        如果一个值可以被转换为true，那么这个值就是所谓的truthy，如果可以被转换为false，那么这个值就是所谓的falsy。会被转换为false的表达式有: null、NaN、0、空字符串、undefined。
        尽管&&和||运算符能够使用非布尔值的操作数，但它们依然可以被看作是布尔操作符，因为它们的返回值总是能够被转换为布尔值，如果要显式地将它们的返回值或者表达式转换为布尔值，可以使用双重非运算符即!!或者Boolean构造函数。
        ```
        &&: AND，逻辑与，expr1 && expr2，若expr1可转换为true则返回expr2，否则返回expr1。
        ||: OR，逻辑或，expr1 || expr2，若expr1可转换为true则返回expr1，否则返回expr2。
        !: NOT，逻辑非，!expr，若expr可转换为true则返回false，否则返回true。
          ECMAScript 规范认为，既然 null 和  undefined 的行为很相似，并且都表示 一个无效的值，那么它们所表示的内容也具有相似性，即有 undefined == null; //true
          用一句话总结两者的区别就是：undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。
          通过Object.prototype.toString.call() 获取javascript对象的真实数据类型 undefined也行
          // 原型及原型链
          对象首先在显示原型(prototype) 上查找属性,找不到再到__proto__中查找属性
        .hasOwnProperty("名称") 验证是否是对象本身的属性
         通过__proto__将对象联系在一起形成了一条原型链,最终指向了Object=>null
        {} instanceof Array 不在这条原型链中,所以返回false 
         // 通过手动实现一个jQuery插件理解原型及原型链
         // 原型的本质 原型及原型链图
         // instanceof 判断是否是这个类要看原型链是否有参与构建这个对象的类
         无论jQuery的逻辑多复杂,只要将selector通过super(selector)传递给"父"类处理即可
        通过super.方法名称就可以调用父类中的方法,同一个类中调用方法需要加上this
     #### 闭包应用
     闭包的第一种应用,在函数中间定义变量,直接作为返回值使用
    通过函数作为参数的情况下实现闭包 一般用于异步函数获取需要的值
    所有自由变量的查找都是从函数定义的地方向上级作用域查找,不是从执行的地方查找
    this的指向,this的指向是由函数执行(调用)的时候决定的,而不是定义的时候
    bind会复制函数,需要调动才能执行
    ### js异步及异步进阶
    #### event loop
    js是线程语言
    js和DOM渲染共用一个线程,需要留出一点时间供DOM渲染
    执行顺序轮询结束 同步代码(直接执行 call stack(同步执行栈))=>异步代码(等待时机 (放入callback Queue 异步队列)) => call stack(清空) => 执行微任务(micor Queue) => 执行DOM渲染 => 执行宏任务(setTimeout,ajax,DOM事件等) => event loop => 
    callback Queue => call stack(在同步执行栈中执行异步代码)  
    Promise 解决的问题 callback hell(回调地狱)
    Promise的状态 pengding fulfilled,rejected pengding=> fulfilled pending=> rejected 状态是不可逆的
     总结: then正常返回fulfilled(已完成),里面有报错返回rejected
           catch正常返回fulfilled,里面有报错返回rejected
     for...of: 适用于异步代码
     ```
      const promise = (nums) => {
        return new Promise((resolve, reject) => {
            const proudct = nums * nums
            setTimeout(() => {
                resolve(proudct)
            }, 1000)
        })
    }
    const arr = [2, 5, 8, 10]
    for-of i代表数组中的每一个值,for-in代表索引
        !(async function() {
            for (let i of arr) {
                const results4 = await promise(i)
                console.log(results4)
            }
        })()
     ```
    ##### await/async
    1. async 后面返跟的是一个Promise对象,如果不是则会封装成一个Promise对象
    2. await 相当于Promise.thne() 正常情况下输出 // await后面如果跟一个具体的值也会封装成 Promise.resolve(value) 输出
    3. 用try...catch 代替Promise.catch() 异常捕获
    4. 函数直接执行 await后面的代码可以看成setTimeout或者Promise.resolve.then()的回调中的代码,在Queue callback中记录
    5. 示例: then(res=>{console.log("async2 start")})
    6. 注意执行顺序,最后执行 await fo2() 下的console.log("async1 start") 符合event loop的执行规则
    7. 异步本质: js语言是单线程的,js的异步需要回调(callback Queue)基于event loop
    8. 不同的异步任务执行的时机也不一样
    9. 宏任务 setTimeout/setInterval ajax /DOM事件
    10. 微任务 Promise / async 和 await
    11. 微任务的执行时机比宏任务早
    12. 微任务在DOM渲染之前执行,宏任务在DOM渲染之后执行

        ```
        ###### 补充 Object.defineProperty(目标对象(obj),prop(属性),{}(属性配置项))
        1. 对象是由多个键/值对组成的无序的集合。对象中每个属性可以是任意类型的值。
          对于对象上已经有的属性，可以通过Object.defineProperty() 第三个参数设置该属性的一些特性，即是否可写，是否可迭代等。
        //对于对象上没有的属性，我们可以通过Object.defineProperty()来给该对象添加属性。
         通过Object.definePropery没有设置特性,默认特性值为false,添加新的属性,没有设置value默认值是undefined
        for...of(用于默认可迭代的对象(Array,String)) for...in(用于可以循环枚举的属性集合(对象)) 对象属性默认是可枚举的
        for...in 与 for...of的区别for...in可以同时获取对象的键和值for...of默认获取到值
        value: 添加属性值
        writable: 属性值是否可写
         enumerable: 是否可以迭代(循环遍历)
         configruable: 是否可以修改目标对象的特性(wriable,enumerable等)
        ```
